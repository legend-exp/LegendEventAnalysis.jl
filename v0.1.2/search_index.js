var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:module]","category":"page"},{"location":"api/#Types-and-constants","page":"API","title":"Types and constants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type, :constant]","category":"page"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:macro, :function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [LegendEventAnalysis]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"api/#LegendEventAnalysis.apply_event_map-Tuple{StructArrays.StructVector, StructArrays.StructVector}","page":"API","title":"LegendEventAnalysis.apply_event_map","text":"apply_event_map(data::StructVector, evtmap::StructVector)\n\nApply the event map evtmap to the data data.\n\ndata will typically be the result of flatten_over_channels and evtmap the result of build_global_event_map.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendEventAnalysis.build_cross_system_events-Tuple{NamedTuple}","page":"API","title":"LegendEventAnalysis.build_cross_system_events","text":"function build_cross_system_events(\n    data::NamedTuple,\n    ts_window::Number = 25u\"μs\"\n)\n\nBuild cross-system events.\n\ndata must be a NamedTuple with properties that represent the names of experiment (sub)-systems and values that are the result of build_global_events for each system.\n\nNote: Currently requires the tstart columns of all systems to be identical.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendEventAnalysis.build_global_event_map-Tuple{StructArrays.StructVector}","page":"API","title":"LegendEventAnalysis.build_global_event_map","text":"build_global_event_map(local_events::StructArray; ts_window::Number = 25u\"μs\")\n\nBuild a map of global events based on local_events.\n\ndata must contain columns channel, chevtno and timestamp. It will typically be the result of flatten_over_channels.\n\nReturns a StructArray that contains the columns start, channels, localevents and timestamps, sorted by start globally and along timestamps in each row.\n\nThe start column contains the start time of each event, the channels, chevts and timestamps columns are vectors of vectors that contain the channel-id, per-channel event numbers and per-channel timestamps that have been associated with each respective events.\n\nPer-channel events are accociated with the same global event if their timestamps fall within a time windows of length ts_window.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendEventAnalysis.build_global_events","page":"API","title":"LegendEventAnalysis.build_global_events","text":"function build_global_events(\n    data::AbstractDict{<:ChannelIdLike},\n    channels::AbstractVector{<:ChannelIdLike} = collect(keys(data));\n    ts_window::Number = 25u\"μs\"\n)\n\nBuild global events from a dictionary of per-channel events\n\nPer-channel events are accociated with the same global event if their timestamps fall within a time windows of length ts_window.\n\ndata must a dictionary of in-memory or on-disk table-like objects, keyed by channel-IDs. It may, e.g. be a Dict with values that are StructArrays.StructVector, TypedTables.Table or similar, but may also be a LegendHDF5IO.LHDataStore. Note that on-disk data will be read into memory as a whole.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendEventAnalysis.calibrate_all-Tuple{LegendDataManagement.LegendData, LegendDataManagement.AnyValiditySelection, AbstractDict}","page":"API","title":"LegendEventAnalysis.calibrate_all","text":"calibrate_all(data::LegendData, sel::ValiditySelection, datastore::AbstractDict)\n\nCalibrate all channels in the given datastore, using the metadata processing configuration for data and sel.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendEventAnalysis.calibrate_ged_channel_data-Tuple{LegendDataManagement.LegendData, LegendDataManagement.AnyValiditySelection, LegendDataManagement.DetectorId, AbstractVector}","page":"API","title":"LegendEventAnalysis.calibrate_ged_channel_data","text":"calibrate_ged_channel_data(data::LegendData, sel::ValiditySelection, detector::DetectorId, channel_data::AbstractVector)\n\nApply the calibration specified by data and sel for the given HPGe detector to the single-channel channel_data for that detector.\n\nAlso calculates the configured cut/flag values.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendEventAnalysis.calibrate_pls_channel_data-Tuple{LegendDataManagement.LegendData, LegendDataManagement.AnyValiditySelection, LegendDataManagement.DetectorId, AbstractVector}","page":"API","title":"LegendEventAnalysis.calibrate_pls_channel_data","text":"calibrate_pls_channel_data(data::LegendData, sel::ValiditySelection, detector::DetectorId, channel_data::AbstractVector)\n\nApply the calibration specified by data and sel for pulser referred to by the detector ID to the single-channel channel_data for that detector.\n\nAlso calculates the configured cut/flag values.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendEventAnalysis.calibrate_spm_channel_data-Tuple{LegendDataManagement.LegendData, LegendDataManagement.AnyValiditySelection, LegendDataManagement.DetectorId, AbstractVector}","page":"API","title":"LegendEventAnalysis.calibrate_spm_channel_data","text":"calibrate_spm_channel_data(data::LegendData, sel::ValiditySelection, detector::DetectorId, channel_data::AbstractVector)\n\nApply the calibration specified by data and sel for the given SiPM detector to the single-channel channel_data for that detector.\n\nAlso calculates the configured cut/flag values.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendEventAnalysis.flag_coincidences-Tuple{AbstractVector{<:Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real}, AbstractVector{<:Union{Unitful.Quantity{<:var\"#s1\"}, var\"#s1\"} where var\"#s1\"<:Real}}","page":"API","title":"LegendEventAnalysis.flag_coincidences","text":"flag_coincidences(\n    timestamps::AbstractVector{<:RealQuantity}, ref_timestamps::AbstractVector{<:RealQuantity};\n    ts_window::Number = 125u\"μs\"\n)\n\nFlag coincidences in timestamps with respect to ref_timestamps.\n\nReturn a boolean vector of the same length as timestamps that is true where a timestamp is within ts_window of an element of ref_timestamps and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendEventAnalysis.flatten_over_channels","page":"API","title":"LegendEventAnalysis.flatten_over_channels","text":"function flatten_over_channels(\n    data::AbstractDict{<:ChannelIdLike},\n    channels::AbstractVector{<:ChannelIdLike} = collect(keys(data))\n)\n\nFlatten per-channel data data to a single StructArrays.StructVector by concatenating its table-like values and adding the columns a channel and chevtno.\n\ndata must a dictionary of in-memory or on-disk table-like objects, keyed by channel-IDs. It may, e.g. be a Dict with values that are StructArrays.StructVector, TypedTables.Table or similar, but may also be a LegendHDF5IO.LHDataStore. Note that on-disk data will be read into memory as a whole.\n\nReturns a NamedTuple{(:result, :per_channel)}: result is the flattened data and per_channel is a channel-indexed dictionary of views into result.\n\n\n\n\n\n","category":"function"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#LegendEventAnalysis.jl","page":"Home","title":"LegendEventAnalysis.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LegendDataManagement.jl provides a Julia implementation of LEGEND global event analysis tools.","category":"page"}]
}
