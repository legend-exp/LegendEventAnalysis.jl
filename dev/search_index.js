var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Modules","page":"API","title":"Modules","text":"Order = [:module]","category":"section"},{"location":"api/#Types-and-constants","page":"API","title":"Types and constants","text":"Order = [:type, :constant]","category":"section"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"Order = [:macro, :function]","category":"section"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/#LegendEventAnalysis.apply_event_map-Tuple{StructArrays.StructVector, StructArrays.StructVector}","page":"API","title":"LegendEventAnalysis.apply_event_map","text":"apply_event_map(data::StructVector, evtmap::StructVector)\n\nApply the event map evtmap to the data data.\n\ndata will typically be the result of flatten_over_detectors and evtmap the result of build_global_event_map.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendEventAnalysis.build_cross_system_events-Tuple{NamedTuple}","page":"API","title":"LegendEventAnalysis.build_cross_system_events","text":"function build_cross_system_events(\n    data::NamedTuple,\n    ts_window::Number = 25u\"μs\"\n)\n\nBuild cross-system events.\n\ndata must be a NamedTuple with properties that represent the names of experiment (sub)-systems and values that are the result of build_global_events for each system.\n\nNote: Currently requires the tstart columns of all systems to be identical.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendEventAnalysis.build_global_event_map-Tuple{StructArrays.StructVector}","page":"API","title":"LegendEventAnalysis.build_global_event_map","text":"build_global_event_map(local_events::StructArray; ts_window::Number = 25u\"μs\")\n\nBuild a map of global events based on local_events.\n\ndata must contain columns detector, detevtno and timestamp. It will typically be the result of flatten_over_detectors.\n\nReturns a StructArray that contains the columns tstart, detector, detevtno and timestamp, sorted by tstart globally and along timestamp in each row.\n\nThe tstart column contains the start time of each event, the detector, detevtno and timestamp columns are vectors of vectors that contain the detector-id, per-detector event numbers and per-detector timestamps that have been associated with each respective events.\n\nPer-detector events are associated with the same global event if their timestamps fall within a time windows of length ts_window.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendEventAnalysis.build_global_events","page":"API","title":"LegendEventAnalysis.build_global_events","text":"function build_global_events(\n    data::AbstractDict{<:DetectorIdLike},\n    detectors::AbstractVector{<:DetectorIdLike} = collect(keys(data));\n    ts_window::Number = 25u\"μs\"\n)\n\nBuild global events from a dictionary of per-detector events\n\nPer-detector events are associated with the same global event if their timestamps fall within a time windows of length ts_window.\n\ndata must a dictionary of in-memory or on-disk table-like objects, keyed by detector-IDs. It may, e.g. be a Dict with values that are StructArrays.StructVector, TypedTables.Table or similar, but may also be a LegendHDF5IO.LHDataStore. Note that on-disk data will be read into memory as a whole.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendEventAnalysis.calibrate_all","page":"API","title":"LegendEventAnalysis.calibrate_all","text":"calibrate_all(data::LegendData, sel::ValiditySelection, datastore::AbstractDict)\n\nCalibrate all detectors in the given datastore, using the metadata processing configuration for data and sel.\n\n\n\n\n\n","category":"function"},{"location":"api/#LegendEventAnalysis.calibrate_aux_detector_data-Tuple{LegendDataManagement.LegendData, LegendDataManagement.AnyValiditySelection, LegendDataManagement.DetectorId, AbstractVector}","page":"API","title":"LegendEventAnalysis.calibrate_aux_detector_data","text":"calibrate_aux_detector_data(data::LegendData, sel::ValiditySelection, detector::DetectorId, detector_data::AbstractVector)\n\nApply the calibration specified by data and sel for aux detector referred to by the detector ID to the single-detector detector_data for that detector.\n\nAlso calculates the configured cut/flag values.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendEventAnalysis.calibrate_ged_detector_data-Tuple{LegendDataManagement.LegendData, LegendDataManagement.AnyValiditySelection, LegendDataManagement.DetectorIdLike, AbstractVector}","page":"API","title":"LegendEventAnalysis.calibrate_ged_detector_data","text":"calibrate_ged_detector_data(data::LegendData, sel::AnyValiditySelection, detector::DetectorId, detector_data::AbstractVector; \n    psd_cal_pars_type::Symbol=:ppars, psd_cal_pars_cat::Symbol=:aoe, psd_cut_pars_type::Symbol=:ppars, psd_cut_pars_cat::Symbol=:aoe,\n    keep_detdata::Bool=false)\n\nApply the calibration specified by data and sel for the given HPGe detector to the single-detector detector_data for that detector.\n\nAlso calculates the configured cut/flag values.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendEventAnalysis.calibrate_pmt_detector_data-Tuple{LegendDataManagement.LegendData, LegendDataManagement.AnyValiditySelection, LegendDataManagement.DetectorId, AbstractVector}","page":"API","title":"LegendEventAnalysis.calibrate_pmt_detector_data","text":"calibrate_pmt_detector_data(data::LegendData, sel::ValiditySelection, detector::DetectorId, detector_data::AbstractVector)\n\nApply the calibration specified by data and sel for the given PMT detector to the single-detector detector_data for that detector.\n\nAlso calculates the configured cut/flag values.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendEventAnalysis.calibrate_spm_detector_data-Tuple{LegendDataManagement.LegendData, LegendDataManagement.AnyValiditySelection, LegendDataManagement.DetectorId, AbstractVector}","page":"API","title":"LegendEventAnalysis.calibrate_spm_detector_data","text":"calibrate_spm_detector_data(data::LegendData, sel::ValiditySelection, detector::DetectorId, detector_data::AbstractVector)\n\nApply the calibration specified by data and sel for the given SiPM detector to the single-detector detector_data for that detector.\n\nAlso calculates the configured cut/flag values.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendEventAnalysis.flag_coincidences-Tuple{AbstractVector{<:Union{Real, Unitful.AbstractQuantity{<:Real}}}, AbstractVector{<:Union{Real, Unitful.AbstractQuantity{<:Real}}}}","page":"API","title":"LegendEventAnalysis.flag_coincidences","text":"flag_coincidences(\n    timestamps::AbstractVector{<:RealQuantity}, ref_timestamps::AbstractVector{<:RealQuantity};\n    ts_window::Number = 125u\"μs\"\n)\n\nFlag coincidences in timestamps with respect to ref_timestamps.\n\nReturn a boolean vector of the same length as timestamps that is true where a timestamp is within ts_window of an element of ref_timestamps and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#LegendEventAnalysis.flatten_over_detectors","page":"API","title":"LegendEventAnalysis.flatten_over_detectors","text":"function flatten_over_detectors(\n    data::AbstractDict{<:DetectorIdLike},\n    detectors::AbstractVector{<:DetectorIdLike} = collect(keys(data))\n)\n\nFlatten per-detector data data to a single StructArrays.StructVector by concatenating its table-like values and adding the columns detector and detevtno.\n\ndata must a dictionary of in-memory or on-disk table-like objects, keyed by detector-IDs. It may, e.g. be a Dict with values that are StructArrays.StructVector, TypedTables.Table or similar, but may also be a LegendHDF5IO.LHDataStore. Note that on-disk data will be read into memory as a whole.\n\nReturns a NamedTuple{(:result, :per_detector)}: result is the flattened data and per_detector is a detector-indexed dictionary of views into result.\n\n\n\n\n\n","category":"function"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"section"},{"location":"#LegendEventAnalysis.jl","page":"Home","title":"LegendEventAnalysis.jl","text":"LegendDataManagement.jl provides a Julia implementation of LEGEND global event analysis tools.","category":"section"}]
}
